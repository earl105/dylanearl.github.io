<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snap Scrolling with Consistent Magnetism</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        html, body {
            overflow-x: hidden;
            height: 100%;
            width: 100%;
        }
        
        .section {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 2rem;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        p {
            font-size: 1.5rem;
            max-width: 600px;
        }
        
        .section:nth-child(1) {
            background: linear-gradient(135deg, #3498db, #2c3e50);
        }
        
        .section:nth-child(2) {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        .section:nth-child(3) {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }
        
        .section:nth-child(4) {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
        }
        
        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .indicator.active {
            background-color: white;
        }
    </style>
</head>
<body>
    <div class="section" id="section1">
        <h1>Section One</h1>
        <p>Scroll down to explore more sections. The page will always snap into place when you stop scrolling.</p>
    </div>
    
    <div class="section" id="section2">
        <h1>Section Two</h1>
        <p>No matter where you stop between sections, it will snap to the section that takes up most of your screen.</p>
    </div>
    
    <div class="section" id="section3">
        <h1>Section Three</h1>
        <p>The magnetism effect is consistent now, even if you stop with one section 95% visible.</p>
    </div>
    
    <div class="section" id="section4">
        <h1>Section Four</h1>
        <p>The final section. Try scrolling back up to experience the improved snap effect!</p>
    </div>
    
    <div class="scroll-indicator">
        <div class="indicator active" data-section="section1"></div>
        <div class="indicator" data-section="section2"></div>
        <div class="indicator" data-section="section3"></div>
        <div class="indicator" data-section="section4"></div>
    </div>
    
    <script>
        // Variables to track scrolling state
        let isScrolling = false;
        let scrollTimer = null;
        let sections = [];
        let indicators = [];
        let currentSection = 0;
        let isSnapping = false;
        
        // Initialize everything when the page loads
        window.addEventListener('DOMContentLoaded', initialize);
        
        function initialize() {
            getSections();
            setupIndicators();
            
            // Set up event listeners
            window.addEventListener('scroll', handleScroll);
            window.addEventListener('touchmove', handleScrollStart);
            window.addEventListener('wheel', handleScrollStart);
            window.addEventListener('touchstart', handleScrollStart);
            window.addEventListener('mousedown', handleScrollStart);
            window.addEventListener('touchend', scheduleScrollEndCheck);
            window.addEventListener('mouseup', scheduleScrollEndCheck);
            window.addEventListener('resize', handleResize);
            
            // Initial update of indicators based on starting position
            getNearestSectionAndSnap(false);
        }
        
        function getSections() {
            sections = Array.from(document.querySelectorAll('.section'));
            indicators = Array.from(document.querySelectorAll('.indicator'));
        }
        
        function setupIndicators() {
            indicators.forEach((indicator, index) => {
                indicator.addEventListener('click', () => scrollToSection(index));
            });
        }
        
        function updateIndicators(index) {
            currentSection = index;
            
            indicators.forEach((indicator, i) => {
                if (i === index) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                }
            });
        }
        
        function scrollToSection(index) {
            if (index < 0 || index >= sections.length) return;
            
            isSnapping = true;
            const targetPosition = index * window.innerHeight;
            
            window.scrollTo({
                top: targetPosition,
                behavior: 'smooth'
            });
            
            updateIndicators(index);
            
            // Reset snapping flag after animation completes
            setTimeout(() => {
                isSnapping = false;
            }, 1000);
        }
        
        function getNearestSectionAndSnap(shouldSnap = true) {
            // Don't interrupt an ongoing snap animation
            if (isSnapping) return currentSection;
            
            const scrollPosition = window.scrollY;
            const viewportHeight = window.innerHeight;
            const viewportMiddle = scrollPosition + (viewportHeight / 2);
            
            // Find which section the middle of the viewport is in
            let nearestSection = Math.floor(viewportMiddle / viewportHeight);
            
            // Calculate how much of each section is visible
            const sectionVisibility = sections.map((section, index) => {
                const sectionTop = index * viewportHeight;
                const sectionBottom = sectionTop + viewportHeight;
                
                // Calculate how much of this section is visible in the viewport
                const visibleTop = Math.max(sectionTop, scrollPosition);
                const visibleBottom = Math.min(sectionBottom, scrollPosition + viewportHeight);
                const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                
                return {
                    index,
                    visibility: visibleHeight / viewportHeight
                };
            });
            
            // Sort by visibility (most visible first)
            sectionVisibility.sort((a, b) => b.visibility - a.visibility);
            
            // The section with most visibility is our target
            nearestSection = sectionVisibility[0].index;
            
            // Clamp to valid range
            nearestSection = Math.max(0, Math.min(nearestSection, sections.length - 1));
            
            // Update indicators
            updateIndicators(nearestSection);
            
            // Snap to the section if requested
            if (shouldSnap && nearestSection !== currentSection) {
                scrollToSection(nearestSection);
            } else if (shouldSnap && Math.abs(scrollPosition - (nearestSection * viewportHeight)) > 5) {
                // Also snap if we're not perfectly aligned with the current section
                scrollToSection(nearestSection);
            }
            
            return nearestSection;
        }
        
        function handleScrollStart() {
            isScrolling = true;
            clearScrollTimer();
        }
        
        function scheduleScrollEndCheck() {
            clearScrollTimer();
            scrollTimer = setTimeout(handleScrollEnd, 150);
        }
        
        function handleScrollEnd() {
            isScrolling = false;
            
            // Always snap to nearest section when scrolling ends
            getNearestSectionAndSnap(true);
        }
        
        function clearScrollTimer() {
            if (scrollTimer) {
                clearTimeout(scrollTimer);
                scrollTimer = null;
            }
        }
        
        function handleScroll() {
            // If not already scrolling (e.g., programmatic scroll), mark as scrolling
            if (!isSnapping) {
                isScrolling = true;
            }
            
            // Reset the timer each time we scroll
            clearScrollTimer();
            
            // Wait for scrolling to stop before snapping
            scrollTimer = setTimeout(handleScrollEnd, 150);
        }
        
        function handleResize() {
            // Recalculate sections on window resize
            getSections();
            
            // Re-snap to current section to maintain proper alignment
            scrollToSection(currentSection);
        }
    </script>
</body>
</html>